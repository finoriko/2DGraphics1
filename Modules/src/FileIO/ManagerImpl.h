#ifndef INCLUDED_GAMELIB_FILEIO_MANAGERIMPL_H
#define INCLUDED_GAMELIB_FILEIO_MANAGERIMPL_H

#include "GameLib/GameLib.h"
#include "GameLib/FileIO/Manager.h"
#include "GameLib/Threading/Thread.h"
#include "GameLib/Threading/Mutex.h"
#include "GameLib/Threading/Event.h"
#include "GameLib/Threading/Functions.h"
#include "FileIO/InFileImpl.h"
#include "FileIO/OutFileImpl.h"
#include "FileIO/Archive.h"
#include <map>
#include <list>
#include <string>
#include <sstream>
#include <fstream>

namespace GameLib {
	namespace FileIO {
		using namespace std;
		using namespace GameLib::Threading;

		class ManagerImpl {
		public:
			class OutRequest {
			public:
				OutRequest(
					const char* fileName,
					const char* data,
					int size,
					int id,
					bool isAuto) :
					mFileName(fileName),
					mData(0),
					mSize(size),
					mId(id),
					mIsAuto(isAuto) {
					// 통째로 복사
					mData = NEW char[size];
					for (int i = 0; i < size; ++i) {
						mData[i] = data[i];
					}
				}
				~OutRequest() {
					SAFE_DELETE_ARRAY(mData);
					mSize = 0;
				}
				int size() const {
					return mSize;
				}
				const char* data() const {
					return mData;
				}
				const char* fileName() const {
					return mFileName.c_str();
				}
				bool isAuto() const {
					return mIsAuto;
				}
				int id() const {
					return mId;
				}
				string mFileName;
				char* mData;
				int mSize;
				int mId;
				bool mIsAuto;
			};
			class LoadThread : public Thread {
			public:
				LoadThread(ManagerImpl* manager) : mManager(manager) {
				}
				~LoadThread() {
					wait(); //종료를 기다림
					mManager = 0; //변수를 버린다
				}
			private:
				void operator()() {
					// 종료 요청되지 않는 동안 무한 루프
					while (!mManager->isEndRequested()) {
						mManager->update();
					}
				}
				ManagerImpl* mManager;
			};
			typedef map< string, InFile::Impl* > InMap;
			typedef InMap::iterator InIt;
			typedef InMap::const_iterator CInIt;

			typedef map< int, OutFile::Impl* > OutMap;
			typedef OutMap::iterator OutIt;
			typedef OutMap::const_iterator COutIt;

			typedef list< string > InList;
			typedef list< OutRequest* > OutList;

			ManagerImpl(
				const char** archiveNames,
				int archiveNumber,
				Manager::AccessMode am) :
				mThread(0),
				mOutRequestId(0),
				mWarningLimit(0x7fffffff),
				mErrorLimit(0x7fffffff),
				mLoadedSum(0),
				mHaltOnError(true),
				mArchives(0),
				mArchiveNumber(0),
				mAccessMode(am) {
				//아카이브 엽니 다
				if (mAccessMode == Manager::MODE_ARCHIVE_FIRST || mAccessMode == Manager::MODE_DIRECT_FIRST) {
					mArchiveNumber = archiveNumber + 1;
				}
				else {
					mArchiveNumber = archiveNumber;
				}
				mArchives = static_cast<Archive*>(OPERATOR_NEW(sizeof(Archive) * mArchiveNumber));

				if (mAccessMode == Manager::MODE_DIRECT_FIRST) {
					//처음 더미를 넣는다
					new (&mArchives[0]) Archive(0); //더미. 직접 파일 읽기
					for (int i = 0; i < archiveNumber; ++i) {
						new (&mArchives[i + 1]) Archive(archiveNames[i]);
					}
				}
				else {
					for (int i = 0; i < archiveNumber; ++i) {
						new (&mArchives[i]) Archive(archiveNames[i]);
					}
					if (mAccessMode == Manager::MODE_ARCHIVE_FIRST) {
						new (&mArchives[archiveNumber]) Archive(0); //더미. 직접 파일 읽기
					}
				}
				mMutex = Mutex::create();
				mEndFlag = Event::create();
				mThread = NEW LoadThread(this);
				mThread->start();
			}
			~ManagerImpl() {
				STRONG_ASSERT(mInFiles.size() == 0 && "FileIO::Manager : you must destroy all files!");
				STRONG_ASSERT(mOutFiles.size() == 0 && "FileIO::Manager : writing files exist. IT MUST BE A BUG.");
				for (OutList::iterator i = mOutRequests.begin(); i != mOutRequests.end(); ++i) {
					if ((*i)->isAuto()) {
						SAFE_DELETE(*i);
					}
					else {
						HALT("FileIO::Manager : you must wait all write request!");
					}
				}
				mEndFlag.set();
				SAFE_DELETE(mThread); //삭제

				//아카이브 삭제
				for (int i = 0; i < mArchiveNumber; ++i) {
					mArchives[i].~Archive();
				}
				OPERATOR_DELETE(mArchives);
			}
			InFile::Impl* createInFile(const char* filename) {
				string fn(filename); //string에 이식

				mMutex.lock();
				//먼저 map에 있는지 확인
				InIt it = mInFiles.find(fn);
				if (it == mInFiles.end()) { //없으므로 만들다
					InFile::Impl* f = NEW InFile::Impl();
					it = mInFiles.insert(make_pair(fn, f)).first;
					f->setIterator(it);
					//로드 요구
					mInRequests.push_back(fn);
				}
				else {
					it->second->refer();
				}
				mMutex.unlock();
				return it->second;
			}
			void destroyInFile(InFile::Impl* f) {
				mMutex.lock();
				//이놈이 마지막이라면 삭제
				f->release();
				if (f->referenceCount() == 0) {
					mLoadedSum -= f->size(); //총 용량 감소
					mInFiles.erase(f->iterator());
					SAFE_DELETE(f);
				}
				mMutex.unlock();
			}
			OutFile::Impl* createOutFile(const char* filename, const char* data, int size) {
				mMutex.lock();
				//핸들생성
				OutFile::Impl* f = NEW OutFile::Impl(mOutRequestId);

				//리퀘스트 생성
				OutRequest* req = NEW OutRequest(filename, data, size, mOutRequestId, false);
				//핸들,요청추가
				mOutFiles.insert(make_pair(mOutRequestId, f));
				mOutRequests.push_back(req);
				++mOutRequestId; //다음을 대비하여 인크리먼트
				mMutex.unlock();

				return f;
			}
			void writeFile(const char* filename, const char* data, int size) {
				mMutex.lock();
				//리퀘스트 생성
				OutRequest* req = NEW OutRequest(filename, data, size, mOutRequestId, true);
				++mOutRequestId; //다음을 대비하여 인크리먼트
				//리퀘스트 추가
				mOutRequests.push_back(req);
				mMutex.unlock();
			}
			void destroyOutFile(OutFile::Impl* f) {
				mMutex.lock();
				//이놈이 마지막이라면 삭제
				if (f->referenceCount() == 0) {
					OutIt it = mOutFiles.find(f->id());
					STRONG_ASSERT(it != mOutFiles.end());
					mOutFiles.erase(it);
					SAFE_DELETE(f);
				}
				mMutex.unlock();
			}
			void setLimit(int warning, int error) {
				mWarningLimit = warning;
				mErrorLimit = error;
			}
			void enableHaltOnError(bool f) {
				mHaltOnError = f;
			}
			void update() {
				using namespace std;
				//할 일 없으면 잠시 자고 끝나겠다
				if (mInRequests.size() == 0 && mOutRequests.size() == 0) {
					Threading::sleep(10);
					return;
				}
				read();
				write();
			}
			void read() {
				ostringstream oss;
				//로드 요구 꺼내기
				mMutex.lock();
				if (mInRequests.size() == 0) { //여기서 조사하지 않으면 안 돼
					mMutex.unlock();
					return;
				}
				string fn = mInRequests.front(); //현물카피. 곧 리스트에서 지우고 싶으므로
				mInRequests.pop_front();
				mMutex.unlock();

				bool error = false;
				bool notification = false; //에러를 핸들 쪽으로 알려줄까?

				//파일 오픈
				int archiveIndex = -1;
				int entryIndex = -1;
				ifstream* stream = 0;
				open(&archiveIndex, &stream, &entryIndex, fn.c_str());

				char* buffer = 0;
				int size = 0;

				if (archiveIndex == -1) { //파일을 찾을 수 없다
					oss.str("");
					oss << "FileIO : can't open file! ( " << fn.c_str() << " )";
					cout << oss.str().c_str() << endl;
					if (mHaltOnError) {
						HALT("FileIO : can't open file!");
					}
					error = notification = true;
				}
				else {
					//다음 단계. 사이즈가 정상인지 측정합니다.
					streamsize readSize;
					streamsize originalSize;
					mArchives[archiveIndex].getFileSize(&readSize, &originalSize, entryIndex, stream);
					if (originalSize >= 0x80000000) { //int로는 저장할 수 없어!
						oss.str("");
						oss << "FileIO : file is too big! 2GB is maximum. ( " << fn.c_str() << " )";
						cout << oss.str().c_str() << endl;
						if (mHaltOnError) {
							HALT("FileIO : file is too big! 2GB is maximum.");
						}
						error = notification = true;
					}
					else if (mLoadedSum + originalSize > mErrorLimit) { //한계를 넘었다.
						oss.str("");
						oss << "FileIO : EXCEED ERROR LIMIT! this file is not loaded. ( " << fn.c_str() << " )";
						cout << oss.str().c_str() << endl;
						if (mHaltOnError) {
							HALT("FileIO : EXCEED ERROR LIMIT! this file is not loaded.");
						}
						error = notification = true;
					}
					else if (mLoadedSum + originalSize > mWarningLimit) {
						cout << "FileIO : EXCEED WARNING LIMIT! ( " << fn.c_str() << " )" << endl;
					}

					// 읽기 전 핸들이 있는지 체크
					//핸들 잘 있어?이제 로드 끝났거나 하지 않아?
					mMutex.lock();
					InIt it = mInFiles.find(fn);
					if (it == mInFiles.end()) {
						error = true;
					}
					else {
						if (it->second->isFinished()) { //바보야! 끝나잖아!
							error = true;
						}
					}
					mMutex.unlock();

					if (!error) {
						size = static_cast<int>(readSize);
						//버퍼 확보
						mArchives[archiveIndex].allocate(&buffer, size, entryIndex);
						//읽기
						bool readError = false;
						mArchives[archiveIndex].read(
							&readError,
							buffer,
							size,
							entryIndex,
							stream);
						if (readError) { //읽을 수가 없어. 중간에 파일 지워진다든가.
							oss.str("");
							oss << "FileIO : read error! can't read entire file! ( " << fn.c_str() << " )";
							cout << oss.str().c_str() << endl;
							if (mHaltOnError) {
								HALT("FileIO : read error! can't read entire file!");
							}
							error = notification = true;
						}
						if (!error) {
							//다 읽었다
							size = static_cast<int>(originalSize); //아까까지 압축 후 사이즈였으니까
							buffer[size] = '\0'; //안심 설계. 0종단.
						}
					}
					if (stream) {
						mArchives[archiveIndex].close(&stream);
					}
				}
				//최종 처리
				mMutex.lock();
				InIt it = mInFiles.find(fn); //여기서 한 번 더 있는지 확인
				if (it == mInFiles.end()) { //없다
					error = true;
				}
				if (error) {
					SAFE_DELETE_ARRAY(buffer); //버퍼 개방
					if (notification) {
						if (it != mInFiles.end()) {
							it->second->setError(); //에러 플래그 설정
						}
					}
				}
				else { //정상종료
					it->second->set(buffer, size);
					mLoadedSum += size; //총 용량 추가
				}
				mMutex.unlock();
			}
			void write() {
				ostringstream oss;
				//리퀘스트 꺼내기
				mMutex.lock();
				if (mOutRequests.size() == 0) { //여기서 조사하지 않으면 안 돼
					mMutex.unlock();
					return;
				}
				OutRequest* req = mOutRequests.front();
				mOutRequests.pop_front();
				mMutex.unlock();

				bool isAuto = req->isAuto();
				int id = req->id();
				//파일 오픈
				const char* fileName = req->fileName();
				setlocale(LC_ALL, ""); //이것이 없으면 일본어 파일명을 받을 수 없다.
				ofstream out(fileName, ofstream::binary);
				bool error = false;
				if (!out) {
					oss.str("");
					oss << "FileIO : can't open file! ( " << fileName << " )";
					cout << oss.str().c_str() << endl;
					if (mHaltOnError) {
						HALT("FileIO : can't open file!");
					}
					error = true;
				}
				else {
					//데이터 꺼내기
					int size = req->size();
					const char* data = req->data();
					const char* readPos = data;
					static const int WRITE_UNIT = 1024 * 1024; //1MB
					int rest = size;
					while (!error) {
						int writeSize = min(rest, WRITE_UNIT);
						out.write(readPos, writeSize);
						readPos += writeSize;
						rest -= writeSize;
						STRONG_ASSERT(rest >= 0); //있을 수 없는 일
						if (rest == 0) {
							break; //정상종료
						}
						//진짜 잘 썼어?
						streamsize wroteSize = out.tellp();
						if (wroteSize != (size - rest)) {
							oss.str("");
							oss << "FileIO : write error! can't write entire file! ( " << fileName << " )";
							cout << oss.str().c_str() << endl;
							if (mHaltOnError) {
								STRONG_ASSERT(0 && "FileIO : write error! can't write entire file!");
							}
							error = true;
							break;
						}
						//핸들삭제체크(핸들이있을때만)
						if (!isAuto) {
							mMutex.lock();
							OutIt it = mOutFiles.find(id);
							if (it == mOutFiles.end()) { //으오! 이제 다 왔어요!
								error = true;
							}
							mMutex.unlock();
						}
					}
				}
				//결과 통지
				if (!isAuto) {
					mMutex.lock();
					OutIt it = mOutFiles.find(id);
					if (it != mOutFiles.end()) { //으오! 이제 다 왔어요!
						it->second->setFinished();
						if (error) {
							it->second->setError();
						}
					}
					mMutex.unlock();
				}
				SAFE_DELETE(req); //리퀘스트 파기
			}
			bool isEndRequested() const {
				return mEndFlag.isSet();
			}
			string createListString() const {
				ostringstream oss;
				CInIt i = mInFiles.begin();
				while (i != mInFiles.end()) {
					oss << i->first;
					oss << '\t' << i->second->size();
					oss << '\t' << i->second->referenceCount() << '\n';
					++i;
				}
				string ret = oss.str();
				return ret;
			}
			void open(int* archiveIndex, ifstream** streamOut, int* entryIndex, const char* name) {
				for (int i = 0; i < mArchiveNumber; ++i) {
					*archiveIndex = i;
					mArchives[i].open(streamOut, entryIndex, name);
					if (*streamOut) { //찾았다. 빠진다.
						break;
					}
				}
				if (!(*streamOut)) {
					*archiveIndex = -1; //결국 못 찾았어요.
				}
			}
			Mutex mMutex;
			LoadThread* mThread;
			Event mEndFlag;
			int mOutRequestId;

			InMap mInFiles;
			OutMap mOutFiles;
			InList mInRequests;
			OutList mOutRequests;

			int mWarningLimit;
			int mErrorLimit;
			int mLoadedSum;
			bool mHaltOnError;

			Archive* mArchives;
			int mArchiveNumber;
			Manager::AccessMode mAccessMode;
		};
		extern ManagerImpl* gManagerImpl;

	} //namespace Sound
} //namespace GameLib

#endif